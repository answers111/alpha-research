{"id": "9ea44786-cfaf-4b28-85f7-c454fb2f99ed", "code": "import numpy as np\nfrom numpy.random import default_rng\nimport math\n\n# Prebind convolution and correlation functions for speed\nconvolve_fn = np.convolve\ncorrelate_fn = np.correlate\n\n# For reproducibility\nrng = default_rng(42)\nrng_random = rng.random\nexp = math.exp\ncnz = np.count_nonzero\n\n# Cache for computed ratios to avoid redundant evaluations\nratio_cache = {}\n\n# Compute the sum\u2010to\u2010difference ratio for two 0/1 indicator vectors\ndef compute_ratio(A_ind: np.ndarray, B_ind: np.ndarray) -> float:\n    \"\"\"Compute sum\u2010to\u2010difference ratio |A+B|/|A\u2212B|. Return \u22121.0 if infeasible.\"\"\"\n    # Multi-call caching\n    key = (A_ind.tobytes(), B_ind.tobytes())\n    if key in ratio_cache:\n        return ratio_cache[key]\n    # quick check\n    if not A_ind.any() or not B_ind.any():\n        ratio = -1.0\n    else:\n        # arrays are already int8\n        A_arr = A_ind\n        B_arr = B_ind\n        # use prebound functions to reduce attribute lookups\n        sums = convolve_fn(A_arr, B_arr)\n        num_sums = int((sums > 0).sum())\n        diffs = correlate_fn(A_arr, B_arr, mode='full')\n        num_diffs = int((diffs > 0).sum())\n        if num_diffs == 0:\n            ratio = -1.0\n        else:\n            ratio = num_sums / num_diffs\n    ratio_cache[key] = ratio\n    return ratio\n\n# Helper: perform one balanced swap/add/remove on a boolean indicator array\ndef propose_move(ind: np.ndarray) -> np.ndarray:\n    \"\"\"Perform a swap or multi-swap move to maintain constant cardinality and improve exploration.\"\"\"\n    ones = np.flatnonzero(ind)\n    zeros = np.flatnonzero(ind == 0)\n    if ones.size and zeros.size:\n        # with small probability do a two-bit swap for larger jumps\n        if rng_random() < 0.3 and ones.size > 1 and zeros.size > 1:  # higher chance for multi-bit swaps\n            removes = rng.choice(ones, size=2, replace=False)\n            adds = rng.choice(zeros, size=2, replace=False)\n            ind[removes] = False\n            ind[adds] = True\n        else:\n            i_remove = rng.choice(ones)\n            i_add = rng.choice(zeros)\n            ind[i_remove] = False\n            ind[i_add] = True\n    return ind\n\n# Configuration constants\nDEFAULT_N = 30\nCONWAY_MSTD_INIT = [0, 2, 3, 4, 7, 11, 12, 14]\nBATCH_SIZE = 20  # increased number of local proposals for better exploration\n\ndef main(N: int = DEFAULT_N) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Perform hill\u2010climbing search starting from the Conway MSTD set of size N.\"\"\"\n    A_ind = np.zeros(N, dtype=np.int8)\n    B_ind = np.zeros(N, dtype=np.int8)\n    A_ind[CONWAY_MSTD_INIT] = True\n    B_ind[:] = A_ind\n\n    # Evaluate initial ratio\n    best_ratio = compute_ratio(A_ind, B_ind)\n    best_A, best_B = A_ind.copy(), B_ind.copy()\n    # Initialize simulated annealing\n    current_A, current_B = best_A.copy(), best_B.copy()\n    current_ratio = best_ratio\n    T = 1.0\n    decay = 0.9999        # slightly slower cooling for extended exploration\n    # restart logic to escape stagnation\n    no_improve = 0\n    max_no_improve = 5000\n\n    # Local search: random single\u2010bit flips\n    max_iter = 50000  # extended search iterations for improved convergence\n    for _ in range(max_iter):\n        # batch multiple proposals to improve exploration\n        local_best_ratio = -1.0\n        local_best_A = None\n        local_best_B = None\n        # Use current state for generating local proposals to enhance search diversity\n        for _ in range(BATCH_SIZE):  # batch size configurable\n            # Generate candidate proposals by copying both state vectors once\n            C_ind, D_ind = current_A.copy(), current_B.copy()\n            if rng_random() < 0.5:\n                C_ind = propose_move(C_ind)\n            else:\n                D_ind = propose_move(D_ind)\n            ratio = compute_ratio(C_ind, D_ind)\n            if ratio > local_best_ratio:\n                local_best_ratio = ratio\n                # Store best candidate references directly (no extra copies)\n                local_best_A, local_best_B = C_ind, D_ind\n        # simulated annealing acceptance\n        delta = local_best_ratio - current_ratio\n        if delta > 0 or rng_random() < exp(delta / T):\n            current_ratio = local_best_ratio\n            current_A, current_B = local_best_A, local_best_B\n        # update global best\n        if current_ratio > best_ratio:\n            best_ratio, best_A, best_B = current_ratio, current_A, current_B\n            no_improve = 0\n        else:\n            no_improve += 1\n        # cool down\n        T *= decay\n        # restart when stagnated\n        if no_improve >= max_no_improve:\n            current_A, current_B = best_A.copy(), best_B.copy()\n            current_ratio = best_ratio\n            T = 1.0\n            no_improve = 0\n\n    print(f\"N={N}, best ratio={best_ratio:.4f}\")\n    return best_A, best_B\n\nif __name__ == \"__main__\":\n    A_ind, B_ind = main()\n    print(\"A_ind:\", A_ind)\n    print(\"B_ind:\", B_ind)\n", "language": "python", "proposal": ["Title: HyperOpt\u0394: Hierarchical Transformer-GFlowNet Meta\u2010Optimization with Active Fidelity and Conformal Surrogates for Extremal Sum\u2010to\u2010Difference Ratio\n\nAbstract  \nDespite recent gains, hill\u2010climbing and static\u2010schedule annealing methods stall near a 1.53 sum\u2010to\u2010difference ratio on N=30 benchmarks. We attribute this plateau to (i) myopic bit\u2010swap proposals, (ii) fixed\u2010fidelity surrogate calls, and (iii) hand\u2010tuned temperature schedules. HyperOpt\u0394 overcomes these bottlenecks through four key innovations:\n\n1. Hierarchical Transformer\u2010GFlowNet Policy  \n \u2022 We embed indicator vectors into a multi\u2010scale graph Transformer that captures local and global structure.  \n \u2022 A hierarchical GFlowNet learns to propose variable\u2010length, high\u2010reward move sequences\u2014ranging from single\u2010bit flips to eight\u2010bit reconfigurations\u2014proportional to their Boltzmann posterior.  \n\n2. Active Fidelity Scheduling with Conformal Uncertainty  \n \u2022 We replace fixed multi\u2010fidelity ensembles with an active\u2010learning controller that issues conformal prediction bands around surrogate outputs.  \n \u2022 A Thompson\u2010sampling bandit selects among cheap linear proxies, mid\u2010cost geometric graph nets, and exact evaluations, dynamically balancing exploration and exploitation with rigorous error guarantees.  \n\n3. Meta\u2010Learnt Temperature & Exploration Prior  \n \u2022 A meta\u2010RL agent, trained across N={30,50,80,120}, adjusts both the inverse\u2010temperature and Transformer\u2010attention dropout in real time.  \n \u2022 By observing acceptance rate, surrogate calibration, and GFlowNet sample diversity, it self\u2010regulates intensification and diversification to escape local traps.  \n\n4. Differentiable Relaxation Warm\u2010Start & Beam\u2010Search Refinement  \n \u2022 Continuous spectral relaxations of the sum\u2010to\u2010difference objective provide gradient\u2010based warm starts, seeding the GFlowNet with promising fractional solutions.  \n \u2022 A beam\u2010search refinement stage evaluates top\u2010k proposals via the active\u2010fidelity ensemble, ensuring precise improvements before committing to expensive exact calls.  \n\nImplementation & Expected Impact  \nBuilt in JAX (surrogates, GFlowNet) and PyTorch (meta\u2010RL, bandit), orchestrated via Ray for distributed search, HyperOpt\u0394 targets ratios >1.9 on N=30\u2013100 in under 10\u00d7 the current compute. Its modular design and conformal\u2010surrogate guarantees promise broad applicability to other extremal combinatorial tasks."], "idea_reward": 6.25, "parent_id": "9b3a7e65-167f-4330-8624-719dae26395d", "generation": 18, "timestamp": 1757817975.7064536, "iteration_found": 1201, "metrics": {"score": 1.53125}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 4 lines with 7 lines\nChange 2: Replace 16 lines with 24 lines\nChange 3: Replace decay = 0.9999        # slightly slower cooling for extended exploration with 4 lines\nChange 4: Replace 4 lines with 13 lines", "parent_metrics": {"score": 1.53125}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour job is to analyze the current program and suggest improvements based on feedback from previous attempts.\nFocus on making targeted changes that will increase the program's performance metrics.\n", "user": "# Previous Proposal: \nTitle: FluxOpt-X: Multi-Fidelity Hypergraph\u2010GFlowNet Meta\u2010Optimization with Self\u2010Calibrating Thermal Control for Extremal Sum\u2010to\u2010Difference Ratio Maximization\n\nAbstract  \nCurrent hill\u2010climbing and surrogate\u2010guided methods plateau at a sum\u2010to\u2010difference ratio of ~1.53 on N=30 benchmarks due to myopic move proposals, fixed\u2010fidelity models, and hand\u2010tuned annealing schedules. We introduce FluxOpt\u2010X, a novel meta\u2010optimization framework that overcomes these bottlenecks through four synergistic innovations:\n\n1. Hypergraph GFlowNet Policy  \n \u2022 We replace isolated bit\u2010swap proposals with a hypergraph\u2010equivariant Generative Flow Network that learns to sample high\u2010reward indicator sequences in proportion to their posterior probabilities.  \n \u2022 By modeling the full joint distribution over move sequences, the GFlowNet captures long\u2010range dependencies and proposes multi\u2010bit reconfigurations that traditional actor\u2010critic policies miss.\n\n2. Adaptive Multi\u2010Fidelity Surrogate Ensemble  \n \u2022 We assemble a three\u2010tier ensemble of (i) lightweight linear proxies, (ii) a deep E(2)\u2010equivariant hypergraph neural net, and (iii) exact convolutional evaluations.  \n \u2022 A Bayesian bandit controller allocates budget across fidelities based on real\u2010time epistemic uncertainty and estimated reward gradients, reducing high\u2010cost exact calls by 85% with no loss in final ratio.\n\n3. Self\u2010Calibrating Thermal Schedule via Meta\u2010Reinforcement Learning  \n \u2022 Rather than fixed decay, we train a meta\u2010RL temperature agent that observes acceptance rate, novelty, and uncertainty to adjust the inverse\u2010temperature on the fly.  \n \u2022 This self\u2010calibration maintains an optimal balance of intensification and diversification, preventing premature convergence and adaptively reopening exploration when plateaus are detected.\n\n4. Graph Attention MCTS Planner with Curriculum Transfer  \n \u2022 We integrate a Graph Attention\u2013guided MCTS to \u201clook ahead\u201d across variable\u2010length move trees up to depth 6, using the surrogate ensemble for rol...(truncated)\n\n# Previous Program:\n```python\nimport numpy as np\nfrom numpy.random import default_rng\nimport math\n\n# Prebind convolution and correlation functions for speed\nconvolve_fn = np.convolve\ncorrelate_fn = np.correlate\n\n# For reproducibility\nrng = default_rng(42)\nrng_random = rng.random\nexp = math.exp\ncnz = np.count_nonzero\n\n# Compute the sum\u2010to\u2010difference ratio for two 0/1 indicator vectors\ndef compute_ratio(A_ind: np.ndarray, B_ind: np.ndarray) -> float:\n    \"\"\"Compute sum\u2010to\u2010difference ratio |A+B|/|A\u2212B|. Return \u22121.0 if infeasible.\"\"\"\n    # quick check\n    if not A_ind.any() or not B_ind.any():\n        return -1.0\n    # arrays are already int8\n    A_arr = A_ind\n    B_arr = B_ind\n    # use prebound functions to reduce attribute lookups\n    sums = convolve_fn(A_arr, B_arr)\n    num_sums = int((sums > 0).sum())\n    diffs = correlate_fn(A_arr, B_arr, mode='full')\n    num_diffs = int((diffs > 0).sum())\n    if num_diffs == 0:\n        return -1.0\n    return num_sums / num_diffs\n\n# Helper: perform one balanced swap/add/remove on a boolean indicator array\ndef propose_move(ind: np.ndarray) -> np.ndarray:\n    \"\"\"Perform a swap or multi-swap move to maintain constant cardinality and improve exploration.\"\"\"\n    ones = np.flatnonzero(ind)\n    zeros = np.flatnonzero(ind == 0)\n    if ones.size and zeros.size:\n        # with small probability do a two-bit swap for larger jumps\n        if rng_random() < 0.3 and ones.size > 1 and zeros.size > 1:  # higher chance for multi-bit swaps\n            removes = rng.choice(ones, size=2, replace=False)\n            adds = rng.choice(zeros, size=2, replace=False)\n            ind[removes] = False\n            ind[adds] = True\n        else:\n            i_remove = rng.choice(ones)\n            i_add = rng.choice(zeros)\n            ind[i_remove] = False\n            ind[i_add] = True\n    return ind\n\n# Configuration constants\nDEFAULT_N = 30\nCONWAY_MSTD_INIT = [0, 2, 3, 4, 7, 11, 12, 14]\nBATCH_SIZE = 20  # increased number of local proposals for better exploration\n\ndef main(N: int = DEFAULT_N) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Perform hill\u2010climbing search starting from the Conway MSTD set of size N.\"\"\"\n    A_ind = np.zeros(N, dtype=np.int8)\n    B_ind = np.zeros(N, dtype=np.int8)\n    A_ind[CONWAY_MSTD_INIT] = True\n    B_ind[:] = A_ind\n\n    # Evaluate initial ratio\n    best_ratio = compute_ratio(A_ind, B_ind)\n    best_A, best_B = A_ind.copy(), B_ind.copy()\n    # Initialize simulated annealing\n    current_A, current_B = best_A.copy(), best_B.copy()\n    current_ratio = best_ratio\n    T = 1.0\n    decay = 0.9999        # slightly slower cooling for extended exploration\n\n    # Local search: random single\u2010bit flips\n    max_iter = 50000  # extended search iterations for improved convergence\n    for _ in range(max_iter):\n        # batch multiple proposals to improve exploration\n        local_best_ratio = -1.0\n        local_best_A = None\n        local_best_B = None\n        # Use current state for generating local proposals to enhance search diversity\n        for _ in range(BATCH_SIZE):  # batch size configurable\n            # Generate candidate proposals by copying both state vectors once\n            C_ind, D_ind = current_A.copy(), current_B.copy()\n            if rng_random() < 0.5:\n                C_ind = propose_move(C_ind)\n            else:\n                D_ind = propose_move(D_ind)\n            ratio = compute_ratio(C_ind, D_ind)\n            if ratio > local_best_ratio:\n                local_best_ratio = ratio\n                # Store best candidate references directly (no extra copies)\n                local_best_A, local_best_B = C_ind, D_ind\n        # simulated annealing acceptance\n        delta = local_best_ratio - current_ratio\n        if delta > 0 or rng_random() < exp(delta / T):\n            current_ratio = local_best_ratio\n            current_A, current_B = local_best_A, local_best_B\n        # update global best\n        if current_ratio > best_ratio:\n            best_ratio, best_A, best_B = current_ratio, current_A, current_B\n        # cool down\n        T *= decay\n\n    print(f\"N={N}, best ratio={best_ratio:.4f}\")\n    return best_A, best_B\n\nif __name__ == \"__main__\":\n    A_ind, B_ind = main()\n    print(\"A_ind:\", A_ind)\n    print(\"B_ind:\", B_ind)\n\n```\n\n# Previous Performance Metrics: \n- score: 1.5312\n\n# Areas Identified for Improvement: \n- Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: score: 1.5588\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: score: 1.5588\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: score: 1.5588\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.5588)\n```python\nimport numpy as np\nfrom numpy.random import default_rng\nimport math\n# Pre\u2010bind exponential for simulated\u2010annealing checks\nexp = math.exp\n\nimport functools\n\nrng = default_rng(42)\nrng_random = rng.random\n# ... (truncated for brevity)\n```\nKey features: Performs well on score (1.5588)\n\n\n### Program 2 (Score: 1.0588)\n```python\nimport numpy as np\nfrom numpy.random import default_rng\n\n# For reproducibility\nrng = default_rng(42)\n# Cache for computed ratios to avoid redundant convolutions\nratio_cache = {}\n\n# Compute the sum\u2010to\u2010difference ratio for two 0/1 indicator vectors\ndef compute_ratio(A_ind: np.ndarray, B_ind: np.ndarray) -> float:\n# ... (truncated for brevity)\n```\nKey features: Performs well on score (1.0588)\n\n\n### Program 3 (Score: -1.0000)\n```python\n# Replace with numpy Generator for reproducible randomness\nimport numpy as np\nrng = np.random.default_rng(42)\nrng_random = rng.random           # pre-bind random for speed\nroll = np.roll                     # pre-bind roll\ncnt = np.count_nonzero            # pre-bind count_nonzero\n\n# Compute the sum\u2010to\u2010difference ratio for two 0/1 indicator vectors\ndef compute_ratio(A_ind, B_ind):\n    S = np.convolve(A_ind, B_ind)\n# ... (truncated for brevity)\n```\nKey features: Performs well on error (-1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.3448)\n```python\nimport numpy as np\nfrom numpy.random import default_rng\n# Removed FFT imports; using numpy.convolve exclusively\n\n# For reproducibility\n# ... (truncated)\n```\nKey features: Alternative approach to score\n\n\n### Program D2 (Score: 1.0000)\n```python\nimport numpy as np\nfrom numpy.random import default_rng\n\n# For reproducibility\nrng = default_rng(42)\n# ... (truncated)\n```\nKey features: Alternative approach to score\n\n\n# Current Proposal\nTitle: HyperOpt\u0394: Hierarchical Transformer-GFlowNet Meta\u2010Optimization with Active Fidelity and Conformal Surrogates for Extremal Sum\u2010to\u2010Difference Ratio\n\nAbstract  \nDespite recent gains, hill\u2010climbing and static\u2010schedule annealing methods stall near a 1.53 sum\u2010to\u2010difference ratio on N=30 benchmarks. We attribute this plateau to (i) myopic bit\u2010swap proposals, (ii) fixed\u2010fidelity surrogate calls, and (iii) hand\u2010tuned temperature schedules. HyperOpt\u0394 overcomes these bottlenecks through four key innovations:\n\n1. Hierarchical Transformer\u2010GFlowNet Policy  \n \u2022 We embed indicator vectors into a multi\u2010scale graph Transformer that captures local and global structure.  \n \u2022 A hierarchical GFlowNet learns to propose variable\u2010length, high\u2010reward move sequences\u2014ranging from single\u2010bit flips to eight\u2010bit reconfigurations\u2014proportional to their Boltzmann posterior.  \n\n2. Active Fidelity Scheduling with Conformal Uncertainty  \n \u2022 We replace fixed multi\u2010fidelity ensembles with an active\u2010learning controller that issues conformal prediction bands around surrogate outputs.  \n \u2022 A Thompson\u2010sampling bandit selects among cheap linear proxies, mid\u2010cost geometric graph nets, and exact evaluations, dynamically balancing exploration and exploitation with rigorous error guarantees.  \n\n3. Meta\u2010Learnt Temperature & Exploration Prior  \n \u2022 A meta\u2010RL agent, trained across N={30,50,80,120}, adjusts both the inverse\u2010temperature and Transformer\u2010attention dropout in real time.  \n \u2022 By observing acceptance rate, surrogate calibration, and GFlowNet sample diversity, it self\u2010regulates intensification and diversification to escape local traps.  \n\n4. Differentiable Relaxation Warm\u2010Start & Beam\u2010Search Refinement  \n \u2022 Continuous spectral relaxations of the sum\u2010to\u2010difference objective provide gradient\u2010based warm starts, seeding the GFlowNet with promising fractional solutions.  \n \u2022 A beam\u2010search refinement stage evaluates top\u2010k proposals via the active\u2010fidelity ensemble, ensuring precise improvements before commi...(truncated)\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["Below are three targeted diffs aimed at speeding up repeated ratio\u2010computations via caching and injecting a simple restart mechanism to escape long stagnation plateaus. The hope is that you can explore more unique proposals per wall\u2010clock time and avoid getting stuck in local optima.\n\n1) Add a global cache for `compute_ratio`  \n2) Wrap `compute_ratio` in that cache  \n3) Introduce a \u201cstagnation counter\u201d and automatic restart  \n\nAll diffs use the exact SEARCH/REPLACE format.\n\n```diff\n<<<<<<< SEARCH\nrng = default_rng(42)\nrng_random = rng.random\nexp = math.exp\ncnz = np.count_nonzero\n=======\nrng = default_rng(42)\nrng_random = rng.random\nexp = math.exp\ncnz = np.count_nonzero\n\n# Cache for computed ratios to avoid redundant evaluations\nratio_cache = {}\n>>>>>>> REPLACE\n```\n\n```diff\n<<<<<<< SEARCH\ndef compute_ratio(A_ind: np.ndarray, B_ind: np.ndarray) -> float:\n    \"\"\"Compute sum\u2010to\u2010difference ratio |A+B|/|A\u2212B|. Return \u22121.0 if infeasible.\"\"\"\n    # quick check\n    if not A_ind.any() or not B_ind.any():\n        return -1.0\n    # arrays are already int8\n    A_arr = A_ind\n    B_arr = B_ind\n    # use prebound functions to reduce attribute lookups\n    sums = convolve_fn(A_arr, B_arr)\n    num_sums = int((sums > 0).sum())\n    diffs = correlate_fn(A_arr, B_arr, mode='full')\n    num_diffs = int((diffs > 0).sum())\n    if num_diffs == 0:\n        return -1.0\n    return num_sums / num_diffs\n=======\ndef compute_ratio(A_ind: np.ndarray, B_ind: np.ndarray) -> float:\n    \"\"\"Compute sum\u2010to\u2010difference ratio |A+B|/|A\u2212B|. Return \u22121.0 if infeasible.\"\"\"\n    # Multi-call caching\n    key = (A_ind.tobytes(), B_ind.tobytes())\n    if key in ratio_cache:\n        return ratio_cache[key]\n    # quick check\n    if not A_ind.any() or not B_ind.any():\n        ratio = -1.0\n    else:\n        # arrays are already int8\n        A_arr = A_ind\n        B_arr = B_ind\n        # use prebound functions to reduce attribute lookups\n        sums = convolve_fn(A_arr, B_arr)\n        num_sums = int((sums > 0).sum())\n        diffs = correlate_fn(A_arr, B_arr, mode='full')\n        num_diffs = int((diffs > 0).sum())\n        if num_diffs == 0:\n            ratio = -1.0\n        else:\n            ratio = num_sums / num_diffs\n    ratio_cache[key] = ratio\n    return ratio\n>>>>>>> REPLACE\n```\n\n```diff\n<<<<<<< SEARCH\n    decay = 0.9999        # slightly slower cooling for extended exploration\n=======\n    decay = 0.9999        # slightly slower cooling for extended exploration\n    # restart logic to escape stagnation\n    no_improve = 0\n    max_no_improve = 5000\n>>>>>>> REPLACE\n```\n\n```diff\n<<<<<<< SEARCH\n        if current_ratio > best_ratio:\n            best_ratio, best_A, best_B = current_ratio, current_A, current_B\n        # cool down\n        T *= decay\n=======\n        if current_ratio > best_ratio:\n            best_ratio, best_A, best_B = current_ratio, current_A, current_B\n            no_improve = 0\n        else:\n            no_improve += 1\n        # cool down\n        T *= decay\n        # restart when stagnated\n        if no_improve >= max_no_improve:\n            current_A, current_B = best_A.copy(), best_B.copy()\n            current_ratio = best_ratio\n            T = 1.0\n            no_improve = 0\n>>>>>>> REPLACE\n```\n\nExplanation of improvements:\n\n- By caching every `(A,B)` evaluation in `ratio_cache`, repeated calls on the same proposals are resolved in O(1) rather than re-running convolution+correlation.\n- A simple stagnation counter (`no_improve`) triggers a restart back to the best-known state whenever no global improvement occurs for `max_no_improve` iterations, helping the search to escape plateaus.\n- These changes should increase effective throughput of unique proposals and reduce wasted cycles on unproductive local minima, boosting your final score."]}}}